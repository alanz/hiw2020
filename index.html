<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Exactprint in GHC (HIW 2020)</title>
<meta name="author" content="(Alan Zimmerman)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="https://alanz.github.io/hiw2020/dist/reveal.css"/>

<link rel="stylesheet" href="https://alanz.github.io/hiw2020/dist/theme/white.css" id="theme"/>

<link rel="stylesheet" href="./local.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'https://alanz.github.io/hiw2020/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">

<section>
<section id="slide-org4481f58">
<h2 id="org4481f58">HIW 2020 - Exactprint in GHC</h2>
<ul>
<li>Alan Zimmerman</li>
<li><a href="https://twitter.com/@alan_zimm"><code class="src src-haskell"><span style="color: #a0522d;">@</span>alan_zimm</code></a></li>

</ul>

</section>
</section>
<section>
<section id="slide-org9a2d71f">
<h2 id="org9a2d71f">Goals of an Exact Printer</h2>
<ul>
<li class="fragment appear">Accurately reproduce the source code, from the <code class="src src-haskell"><span style="color: #228b22;">ParsedSource</span></code></li>
<li class="fragment appear">More important, allow <b>changes</b> to be made
<ul>
<li>purely as transformations of the AST,</li>
<li>such that when printed out the source still reflects the original as much as possible</li>
<li><b>and</b> the code still compiles.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orge4e46a6">
<h3 id="orge4e46a6">Complications</h3>
<ul>
<li class="fragment appear">Haskell is layout sensitive
<ul>
<li>moving things around</li>
<li><p>
changing names to be longer or shorter
</p>
<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #0000ff;">baz</span> <span style="color: #a0522d;">=</span> bar <span style="color: #a020f0;">where</span> x <span style="color: #a0522d;">=</span> 1
                bar <span style="color: #a0522d;">=</span> 2
</code></pre>
</div></li>

</ul></li>
<li class="fragment appear">order in lists - <code class="src src-haskell"><span style="color: #228b22;">SrcSpan</span></code>s are no longer meaningful</li>
<li class="fragment appear">comments</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgaee2117">
<h2 id="orgaee2117">ghc-exactprint</h2>
<ul>
<li class="fragment appear">Initial commit Sep 2014</li>

<li class="fragment appear">Story starts earlier, getting rid of the <code class="src src-haskell"><span style="color: #0000ff;">panic</span> <span style="color: #8b2252;">"blah"</span></code> entries in
the GHC AST</li>

<li class="fragment appear">But the AST did not actually reflect the parsed source
<ul>
<li>information loss during initial parsing</li>
<li>Literals.</li>

</ul></li>

<li class="fragment appear">By <b>GHC 7.10</b> the <code class="src src-haskell"><span style="color: #228b22;">ParsedSource</span></code>
accurately reflected the state of the original source</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgcd7254a">
<h3 id="orgcd7254a">ghc-exactprint is successful</h3>
<ul>
<li>Many tools built on top of it
<ul>
<li>HaRe (now dormant)</li>
<li>apply-refact (for hlint, now moved to GHC AST too)</li>
<li>multiple formatters</li>
<li>retrie</li>
<li>others</li>

</ul></li>

</ul>

<aside class="notes">
<p>
<a href="https://packdeps.haskellers.com/reverse/ghc-exactprint">https://packdeps.haskellers.com/reverse/ghc-exactprint</a>
</p>
<ul>
<li>apply-refact</li>
<li>brittany</li>
<li>HaRe</li>
<li>hgrep</li>
<li>lens-th-rewrite</li>
<li>retrie</li>
<li>smuggler</li>
<li>smuggler2</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-org2fb8ea3">
<h3 id="org2fb8ea3">But</h3>
<ul>
<li>There are problems

<ul>
<li>Annotations added and maintained in GHC, but the library using
them is separate</li>
<li><b>ghc-exactprint</b> is only updated when release time gets near</li>

</ul></li>

<li>This makes it hard for GHC developers to check changes to API
Annotations</li>

</ul>

</section>
</section>
<section>
<section id="slide-org0bf7471">
<h2 id="org0bf7471">Proposed Solution</h2>
<ul>
<li><b>Move the exact printing into the GHC source tree</b>

<ul>
<li>Culmination of multi-year effort</li>
<li>Started with getting <a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/implementing-trees-that-grow">Trees That Grow</a> into the AST</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgeab3db3">
<h3 id="orgeab3db3">Work has started</h3>
<ul>
<li>There has been some sporadic discussion about this on ghc gitlab.</li>
<li>But some things have changed
<ul>
<li>parser cleanup / reorganise <br /></li>
<li>recent <code class="src src-haskell"><span style="color: #228b22;">XRec</span></code> ping-pong landed <br /></li>

</ul></li>
<li><i>Note:</i>
<ul>
<li><i>This is a proposal, for discussion</i></li>
<li><i>It is based on actual work, to see real world implications of the decisions</i></li>

</ul></li>

</ul>

<aside class="notes">
<p>
(Vladislav Zavialov (@int-index))
(Zubin Duggal, Phillipp Kr√ºger)
</p>

</aside>
</section>
</section>
<section>
<section id="slide-org1efae96">
<h3 id="org1efae96">Technical approach</h3>
<ul>
<li>Two main goals
<ul>
<li>Get rid of the <code class="src src-haskell"><span style="color: #228b22;">SrcSpan</span></code> indexing, by moving the annotations into
the <code class="src src-haskell"><span style="color: #228b22;">ParsedSource</span></code></li>
<li><p>
Make the annotations properly typed
</p>
<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #a020f0;">type</span> <span style="color: #228b22;">ApiAnnKey</span> <span style="color: #a0522d;">=</span> (<span style="color: #228b22;">SrcSpan</span>, <span style="color: #228b22;">AnnKeywordId</span>)
<span style="color: #a020f0;">type</span> <span style="color: #228b22;">ApiAnns</span> <span style="color: #a0522d;">=</span> ( <span style="color: #228b22;">Map</span> <span style="color: #228b22;">ApiAnnKey</span> [<span style="color: #228b22;">SrcSpan</span>]
               , <span style="color: #228b22;">Map</span> <span style="color: #228b22;">SrcSpan</span> [<span style="color: #228b22;">Located</span> <span style="color: #228b22;">AnnotationComment</span>])
<span style="color: #a020f0;">data</span> <span style="color: #228b22;">AnnKeywordId</span>
    <span style="color: #a0522d;">=</span> <span style="color: #228b22;">AnnAnyclass</span> <span style="color: #b22222;">-- </span><span style="color: #b22222;">'anyclass'</span>
    <span style="color: #a0522d;">|</span> <span style="color: #228b22;">AnnAs</span>       <span style="color: #b22222;">-- </span><span style="color: #b22222;">'as'</span>
    <span style="color: #a0522d;">|</span> <span style="color: #228b22;">AnnAt</span>       <span style="color: #b22222;">-- </span><span style="color: #b22222;">'at'</span>
</code></pre>
</div></li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org4b0db5c">
<h3 id="org4b0db5c">How does it work for ghc-exactprint?</h3>
<ul>
<li>Input: <code class="src src-haskell"><span style="color: #228b22;">ParsedSource</span></code>, and separate annotations</li>

<li>Convert the original annotations into a <b>delta</b> format, which
tracks the annotation location wrt preceding output.</li>
<li>Keep an explicit list of the order of items, so we do not have to
use the <code class="src src-haskell"><span style="color: #228b22;">SrcSpan</span></code> order, for adding, or
moving items around.</li>

<li>These are still in a separate data structure</li>

</ul>

</section>
</section>
<section>
<section id="slide-org4ebc62c">
<h3 id="org4ebc62c">In-tree annotations</h3>
<ul>
<li>The annotations are <b>inside</b> the tree, using the TTG extension points,
for <code class="src src-haskell"><span style="color: #228b22;">GhcPs</span></code>. There is one per AST element.</li>

<li>Each annotation has a standard structure part, and a
context-sensitive part.</li>

</ul>

</section>
<section id="slide-org5de0e9f">
<h4 id="org5de0e9f">Detail</h4>
<ul>
<li><p>
So we have
</p>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #a020f0;">data</span> <span style="color: #228b22;">ApiAnn'</span> ann
  <span style="color: #a0522d;">=</span> <span style="color: #228b22;">ApiAnn</span> { anchor   <span style="color: #a0522d;">::</span> <span style="color: #228b22;">RealSrcSpan</span>
           , anns     <span style="color: #a0522d;">::</span> ann
           , comments <span style="color: #a0522d;">::</span> [<span style="color: #228b22;">RealLocated</span> <span style="color: #228b22;">AnnotationComment</span>]
           }
  <span style="color: #a0522d;">|</span> <span style="color: #228b22;">ApiAnnNotUsed</span>
</code></pre>
</div>

<ul>
<li><b>all the annotations are used relative to the original anchor,
regardless of where it is used in the tree now</b>.</li>

</ul></li>

</ul>
</section>
<section id="slide-org4c75e74">
<h4 id="org4c75e74">Example</h4>
<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #a020f0;">data</span> <span style="color: #228b22;">ApiAnnHsCase</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">ApiAnnHsCase</span>
      { hsCaseAnnCase <span style="color: #a0522d;">::</span> <span style="color: #228b22;">RealSrcSpan</span> <span style="color: #b22222;">-- </span><span style="color: #b22222;">'case' location</span>
      , hsCaseAnnOf   <span style="color: #a0522d;">::</span> <span style="color: #228b22;">RealSrcSpan</span> <span style="color: #b22222;">-- </span><span style="color: #b22222;">'of' location</span>
      , hsCaseAnnsRest <span style="color: #a0522d;">::</span> [<span style="color: #228b22;">AddApiAnn</span>]
      }
<span style="color: #a020f0;">data</span> <span style="color: #228b22;">AddApiAnn</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">AddApiAnn</span> <span style="color: #228b22;">AnnKeywordId</span> <span style="color: #228b22;">RealSrcSpan</span>
</code></pre>
</div>

<p>
Attached as
</p>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim>  <span style="color: #a0522d;">|</span> <span style="color: #228b22;">HsCase</span>      (<span style="color: #228b22;">XCase</span> p) <span style="color: #b22222;">-- </span><span style="color: #b22222;">TTG extension point</span>
                (<span style="color: #228b22;">LHsExpr</span> p)
                (<span style="color: #228b22;">MatchGroup</span> p (<span style="color: #228b22;">LHsExpr</span> p))

<span style="color: #a020f0;">type</span> <span style="color: #a020f0;">instance</span> <span style="color: #228b22;">XCase</span> <span style="color: #228b22;">GhcPs</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">ApiAnn'</span> <span style="color: #228b22;">ApiAnnHsCase</span> <span style="color: #b22222;">-- </span><span style="color: #b22222;">TTG usage</span>
</code></pre>
</div>

</section>
<section id="slide-org1426021">
<h4 id="org1426021">Concrete Example</h4>
<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #b22222;">-- </span><span style="color: #b22222;">123456789012345</span>
043  <span style="color: #a020f0;">case</span>  x  <span style="color: #a020f0;">of</span>
044    1 <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">True</span>
045    <span style="color: #a0522d;">..</span>
</code></pre>
</div>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim>(<span style="color: #228b22;">HsCase</span>
 (<span style="color: #228b22;">ApiAnn</span>
  { (43,3)<span style="color: #a0522d;">-</span>(45,14) }                        <span style="color: #b22222;">-- </span><span style="color: #b22222;">anchor</span>
  (<span style="color: #228b22;">ApiAnnHsCase</span> { 43<span style="color: #228b22;">:</span>3<span style="color: #a0522d;">-</span>6 } { 43<span style="color: #228b22;">:</span>12<span style="color: #a0522d;">-</span>13 } <span style="color: #228b22;">[]</span>) <span style="color: #b22222;">-- </span><span style="color: #b22222;">anns</span>
  <span style="color: #228b22;">[]</span>)                                       <span style="color: #b22222;">-- </span><span style="color: #b22222;">comments</span>
 (<span style="color: #228b22;">L</span> (<span style="color: #228b22;">SrcSpanAnn</span> (<span style="color: #228b22;">ApiAnnNotUsed</span>) { 43<span style="color: #228b22;">:</span>9 })
  (<span style="color: #228b22;">HsVar</span> <span style="color: #a0522d;">..</span> {<span style="color: #228b22;">OccName:</span> x}))
 (<span style="color: #228b22;">MG</span>
  (<span style="color: #228b22;">NoExtField</span>)
  (<span style="color: #228b22;">L</span> (<span style="color: #228b22;">SrcSpanAnn</span> (<span style="color: #228b22;">ApiAnn</span> { (44,5)<span style="color: #a0522d;">-</span>(45,14) <span style="color: #a0522d;">...</span>))))))
</code></pre>
</div>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim>(<span style="color: #228b22;">DP</span> (0,0),<span style="color: #8b2252;">"case"</span>) <span style="color: #b22222;">-- </span><span style="color: #b22222;">(43, 3)</span>
(<span style="color: #228b22;">DP</span> (0,2),<span style="color: #8b2252;">"x"</span>)    <span style="color: #b22222;">-- </span><span style="color: #b22222;">(43, 9)</span>
(<span style="color: #228b22;">DP</span> (0,2),<span style="color: #8b2252;">"of"</span>)   <span style="color: #b22222;">-- </span><span style="color: #b22222;">(43,12)</span>
(<span style="color: #228b22;">DP</span> (1,2),<span style="color: #8b2252;">"1"</span>)    <span style="color: #b22222;">-- </span><span style="color: #b22222;">(44, 5) wrt (43,3) anchor</span>
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-orgcf35c14">
<h3 id="orgcf35c14"><code class="src src-haskell"><span style="color: #228b22;">Located</span></code> annotations</h3>
<ul>
<li>Some annotations need to apply to all constructors of a data type.</li>

<li>They are needed for specific purposes
<ul>
<li><code class="src src-haskell"><span style="color: #228b22;">RdrName</span></code> decorations:
<code class="src src-haskell"><span style="color: #a0522d;">`foo`</span></code>,
<code class="src src-haskell">'<span style="color: #228b22;">:</span></code>,
<code class="src src-haskell">(<span style="color: #0000ff;">&amp;</span>)</code>,</li>
<li>Contextual usage
<ul>
<li>trailing <code class="src src-haskell">,</code>, <code class="src src-haskell">;</code>, <code class="src src-haskell"><span style="color: #a0522d;">|</span></code></li>

</ul></li>

</ul></li>

<li>We use the fact that AST elements are <code class="src src-haskell"><span style="color: #228b22;">Located</span></code> to piggy-back annotations.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org46aedfa">
<h3 id="org46aedfa"><code class="src src-haskell"><span style="color: #228b22;">XRec</span></code> Locations</h3>
<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #a020f0;">type</span> <span style="color: #a020f0;">family</span> <span style="color: #228b22;">XRec</span> p a <span style="color: #a0522d;">=</span> r <span style="color: #a0522d;">|</span> r <span style="color: #a0522d;">-&gt;</span> a
<span style="color: #8b2252;">-- | We can strip off the XRec to access the underlying data.</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">UnXRec</span> p <span style="color: #a020f0;">where</span>
  unXRec <span style="color: #a0522d;">::</span> <span style="color: #228b22;">XRec</span> p a <span style="color: #a0522d;">-&gt;</span> a
</code></pre>
</div>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #a020f0;">type</span> <span style="color: #a020f0;">instance</span> <span style="color: #228b22;">XRec</span> (<span style="color: #228b22;">GhcPass</span> p) a <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Located</span> a
<span style="color: #a020f0;">type</span> <span style="color: #228b22;">LHsExpr</span> p <span style="color: #a0522d;">=</span> <span style="color: #228b22;">XRec</span> p (<span style="color: #228b22;">HsExpr</span> p)
</code></pre>
</div>

<ul>
<li>This mimics the "old" scheme where everything is located.</li>

<li><p>
For exactprint in GHC we adapt it as
</p>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #a020f0;">type</span> <span style="color: #a020f0;">instance</span> <span style="color: #228b22;">XRec</span> (<span style="color: #228b22;">GhcPass</span> p) a <span style="color: #a0522d;">=</span> <span style="color: #228b22;">GenLocated</span> (<span style="color: #228b22;">Anno</span> a) a

<span style="color: #a020f0;">type</span> <span style="color: #a020f0;">family</span> <span style="color: #228b22;">Anno</span> a <span style="color: #a0522d;">=</span> b
</code></pre>
</div></li>

<li>It is still located, but each AST element has a knob to
set precisely what location type to use.</li>

</ul>
<p>
(<i>Thanks Zubin Duggal for helping me with this</i>)
</p>

</section>
<section id="slide-org072d0b3">
<h4 id="org072d0b3">Kinds of location</h4>
<p>
There is a regular structure for this
</p>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #a020f0;">data</span> <span style="color: #228b22;">SrcSpanAnn'</span> a <span style="color: #a0522d;">=</span> <span style="color: #228b22;">SrcSpanAnn</span> { ann <span style="color: #a0522d;">::</span> a, locA <span style="color: #a0522d;">::</span> <span style="color: #228b22;">SrcSpan</span> }
</code></pre>
</div>

<p>
Example usage
</p>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #a020f0;">type</span> <span style="color: #228b22;">SrcSpanAnnA</span>    <span style="color: #a0522d;">=</span> <span style="color: #228b22;">SrcSpanAnn'</span> (<span style="color: #228b22;">ApiAnn'</span> <span style="color: #228b22;">AnnListItem</span>)
<span style="color: #a020f0;">type</span> <span style="color: #228b22;">SrcSpanAnnName</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">SrcSpanAnn'</span> (<span style="color: #228b22;">ApiAnn'</span> <span style="color: #228b22;">NameAnn</span>)
</code></pre>
</div>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #a020f0;">data</span> <span style="color: #228b22;">AnnListItem</span>
  <span style="color: #a0522d;">=</span> <span style="color: #228b22;">AnnListItem</span> {
      lann_trailing  <span style="color: #a0522d;">::</span> [<span style="color: #228b22;">TrailingAnn</span>]
      }
<span style="color: #a020f0;">data</span> <span style="color: #228b22;">TrailingAnn</span>
  <span style="color: #a0522d;">=</span> <span style="color: #228b22;">AddSemiAnn</span> <span style="color: #228b22;">RealSrcSpan</span>
  <span style="color: #a0522d;">|</span> <span style="color: #228b22;">AddCommaAnn</span> <span style="color: #228b22;">RealSrcSpan</span>
  <span style="color: #a0522d;">..</span>
</code></pre>
</div>

</section>
<section id="slide-org072d0b3-split">
<p>
In "normal" usage we can have
</p>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #a020f0;">type</span> <span style="color: #228b22;">LocatedA</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">GenLocated</span> <span style="color: #228b22;">SrcSpanAnnA</span>
<span style="color: #a020f0;">type</span> <span style="color: #228b22;">LocatedN</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">GenLocated</span> <span style="color: #228b22;">SrcSpanAnnName</span>

<span style="color: #a020f0;">type</span> <span style="color: #228b22;">LocatedAn</span> an <span style="color: #a0522d;">=</span> <span style="color: #228b22;">GenLocated</span> (<span style="color: #228b22;">SrcSpanAnn'</span> (<span style="color: #228b22;">ApiAnn'</span> an))
</code></pre>
</div>

</section>
<section id="slide-orge1eabe8">
<h4 id="orge1eabe8">Putting it all together</h4>
<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #a020f0;">type</span> <span style="color: #228b22;">LHsExpr</span> p <span style="color: #a0522d;">=</span> <span style="color: #228b22;">XRec</span> p (<span style="color: #228b22;">HsExpr</span> p)
<span style="color: #a020f0;">type</span> <span style="color: #a020f0;">instance</span> <span style="color: #228b22;">Anno</span> (<span style="color: #228b22;">HsExpr</span> (<span style="color: #228b22;">GhcPass</span> p)) <span style="color: #a0522d;">=</span> <span style="color: #228b22;">SrcSpanAnnA</span>

<span style="color: #0000ff;">foo</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">LocatedA</span> (<span style="color: #228b22;">HsExpr</span> <span style="color: #228b22;">GhcPs</span>)
<span style="color: #0000ff;">bar</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">LHsExpr</span> <span style="color: #228b22;">GhcPs</span>
</code></pre>
</div>

<p>
Note: in instance declarations, you have to use the
<code class="src src-haskell">foo</code> form, which matches the "after
resolution" <code class="src src-haskell"><span style="color: #228b22;">XRec</span></code> family.
</p>

</section>
</section>
<section>
<section id="slide-org3be984c">
<h3 id="org3be984c">Usage for printing</h3>
<ul>
<li>This part is still under heavy development, but enough has been done
to indicate viability</li>
<li>based heavily on the <b>ghc-exactprint</b> print phase.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org3b22b52">
<h3 id="org3b22b52">Depth-first traversal of the AST</h3>
<ul>
<li>Keeps track of a left margin for current indentation level</li>
<li>Processes each print operation using the "top left corner" as the
reference point.
<ul>
<li>This is the <code class="src src-haskell">anchor</code> field from earlier</li>
<li>implication: there is a "print head" position. It can only move
forward. So all annotated items must come to the right or below the
anchor.</li>

</ul></li>

</ul>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #a020f0;">data</span> <span style="color: #228b22;">Entry</span> <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Entry</span> <span style="color: #228b22;">RealSrcSpan</span> [<span style="color: #228b22;">RealLocated</span> <span style="color: #228b22;">AnnotationComment</span>]
           <span style="color: #a0522d;">|</span> <span style="color: #228b22;">NoEntryVal</span>
</code></pre>
</div>

</section>
<section id="slide-org3b22b52-split">
<ul>
<li>comments are handed to the printer, it inserts them into the
appropriate place in the output stream (modulo the anchor offset).

<ul>
<li>Aside: comments are allowed to go left of the anchor column, but
clip against the left margin.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org15ca5f0">
<h3 id="org15ca5f0">ExactPrint</h3>
<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #a020f0;">class</span> <span style="color: #228b22;">ExactPrint</span> a <span style="color: #a020f0;">where</span>
  getAnnotationEntry <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Entry</span>
  exact <span style="color: #a0522d;">::</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Annotated</span> <span style="color: #228b22;">()</span>
</code></pre>
</div>

<ul>
<li>Note:
<ul>
<li><code class="src src-haskell"><span style="color: #228b22;">ExactPrint</span></code> is analogous to <code class="src src-haskell"><span style="color: #228b22;">Outputable</span></code></li>
<li><code class="src src-haskell">exact</code> is analogous to <code class="src src-haskell">ppr</code></li>

</ul></li>

<li>Printing uses the anchor in the annotation, so the
<code class="src src-haskell">getAnnotationEntry</code> pulls it out if it
exists, together with any comments in the span of the item.</li>

<li>This anchor is used for an <code class="src src-haskell">enterAnn</code> routing</li>

</ul>

</section>
<section id="slide-org15ca5f0-split">
<p>
Simplest example
</p>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #a020f0;">instance</span> (<span style="color: #228b22;">ExactPrint</span> a) <span style="color: #a0522d;">=&gt;</span> <span style="color: #228b22;">ExactPrint</span> (<span style="color: #228b22;">Located</span> a) <span style="color: #a020f0;">where</span>
  getAnnotationEntry (<span style="color: #228b22;">L</span> l <span style="color: #a020f0;">_</span>) <span style="color: #a0522d;">=</span> <span style="color: #228b22;">Entry</span> (realSrcSpan l) <span style="color: #228b22;">[]</span>
  exact (<span style="color: #228b22;">L</span> <span style="color: #a020f0;">_</span> a) <span style="color: #a0522d;">=</span> markAnnotated a
</code></pre>
</div>

<p>
<code class="src src-haskell">markAnnotated</code> manages the process of
descending into an enclosed AST item.
</p>
<aside class="notes">
<ul>
<li>(Aside: the name is a holdover from ghc-exactprint, from the
original process. It is already a misnomer there too)</li>

</ul>

</aside>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #0000ff;">markAnnotated</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">ExactPrint</span> a <span style="color: #a0522d;">=&gt;</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Annotated</span> <span style="color: #228b22;">()</span>
<span style="color: #0000ff;">markAnnotated</span> a <span style="color: #a0522d;">=</span> enterAnn (getAnnotationEntry a) a
</code></pre>
</div>

</section>
<section id="slide-org15ca5f0-split">
<p>
The trivial version of <code class="src src-haskell">enterAnn</code>, but
showing the basic interleaving flow, is
</p>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #0000ff;">enterAnn</span> <span style="color: #a0522d;">::</span> (<span style="color: #228b22;">ExactPrint</span> a) <span style="color: #a0522d;">=&gt;</span> <span style="color: #228b22;">Entry</span> <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Annotated</span> <span style="color: #228b22;">()</span>
<span style="color: #0000ff;">enterAnn</span> <span style="color: #228b22;">NoEntryVal</span> a <span style="color: #a0522d;">=</span> <span style="color: #a020f0;">do</span>
  exact a
</code></pre>
</div>

</section>
<section id="slide-org15ca5f0-split">
<p>
The version where there <b>is</b> an <code class="src src-haskell"><span style="color: #228b22;">EntryVal</span></code>
is
</p>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #0000ff;">enterAnn</span> (<span style="color: #228b22;">Entry</span> anchor cs) a <span style="color: #a0522d;">=</span> <span style="color: #a020f0;">do</span>
  addComments cs
  printComments anchor
  off <span style="color: #a0522d;">&lt;-</span> gets epLHS
  priorEndAfterComments <span style="color: #a0522d;">&lt;-</span> getPos
  <span style="color: #a020f0;">let</span> edp <span style="color: #a0522d;">=</span> adjustDeltaForOffset
              off (ss2delta priorEndAfterComments anchor)
  <span style="color: #a020f0;">let</span>
    st <span style="color: #a0522d;">=</span> annNone { annEntryDelta <span style="color: #a0522d;">=</span> edp }
  withOffset st (advance edp <span style="color: #a0522d;">&gt;&gt;</span> exact a)
</code></pre>
</div>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #0000ff;">withOffset</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Annotation</span> <span style="color: #a0522d;">-&gt;</span> (<span style="color: #228b22;">EPP</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">EPP</span> a)
<span style="color: #0000ff;">withOffset</span> a <span style="color: #a0522d;">=</span>
  local (<span style="color: #a0522d;">\</span>s <span style="color: #a0522d;">-&gt;</span> s { epAnn <span style="color: #a0522d;">=</span> a })
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-org682ac2b">
<h3 id="org682ac2b"><code class="src src-haskell"><span style="color: #228b22;">ExactPrint</span></code> examples</h3>
<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #a020f0;">instance</span> <span style="color: #228b22;">ExactPrint</span> (<span style="color: #228b22;">HsTupArg</span> <span style="color: #228b22;">GhcPs</span>) <span style="color: #a020f0;">where</span>
  getAnnotationEntry <span style="color: #a0522d;">=</span> const <span style="color: #228b22;">NoEntryVal</span>

  exact (<span style="color: #228b22;">Present</span> <span style="color: #a020f0;">_</span> e) <span style="color: #a0522d;">=</span> markAnnotated e
  exact (<span style="color: #228b22;">Missing</span> <span style="color: #a020f0;">_</span>) <span style="color: #a0522d;">=</span> return <span style="color: #228b22;">()</span>
</code></pre>
</div>

</section>
<section id="slide-org682ac2b-split">
<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #a020f0;">instance</span> <span style="color: #228b22;">ExactPrint</span> (<span style="color: #228b22;">HsValBindsLR</span> <span style="color: #228b22;">GhcPs</span> <span style="color: #228b22;">GhcPs</span>) <span style="color: #a020f0;">where</span>
  getAnnotationEntry <span style="color: #a0522d;">=</span> const <span style="color: #228b22;">NoEntryVal</span>

  exact (<span style="color: #228b22;">ValBinds</span> sortkey binds sigs) <span style="color: #a0522d;">=</span> <span style="color: #a020f0;">do</span>
    applyListAnnotations
       (prepareListAnnotationA (bagToList binds)
     <span style="color: #a0522d;">++</span> prepareListAnnotationA sigs
       )
</code></pre>
</div>

</section>
<section id="slide-org682ac2b-split">
<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #0000ff;">prepareListAnnotationA</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">ExactPrint</span> (<span style="color: #228b22;">LocatedAn</span> an a)
  <span style="color: #a0522d;">=&gt;</span> [<span style="color: #228b22;">LocatedAn</span> an a] <span style="color: #a0522d;">-&gt;</span> [(<span style="color: #228b22;">RealSrcSpan</span>,<span style="color: #228b22;">EPP</span> <span style="color: #228b22;">()</span>)]
<span style="color: #0000ff;">prepareListAnnotationA</span> ls
 <span style="color: #a0522d;">=</span> map (<span style="color: #a0522d;">\</span>b <span style="color: #a0522d;">-&gt;</span> (realSrcSpan <span style="color: #a0522d;">$</span> getLocA b,markAnnotated b)) ls

<span style="color: #0000ff;">applyListAnnotations</span> <span style="color: #a0522d;">::</span> [(<span style="color: #228b22;">RealSrcSpan</span>, <span style="color: #228b22;">EPP</span> <span style="color: #228b22;">()</span>)] <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">EPP</span> <span style="color: #228b22;">()</span>
<span style="color: #0000ff;">applyListAnnotations</span> ls <span style="color: #a0522d;">=</span> withSortKey ls
</code></pre>
</div>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #0000ff;">withSortKey</span> <span style="color: #a0522d;">::</span> [(<span style="color: #228b22;">RealSrcSpan</span>, <span style="color: #228b22;">EPP</span> <span style="color: #228b22;">()</span>)] <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">EPP</span> <span style="color: #228b22;">()</span>
<span style="color: #0000ff;">withSortKey</span> xs <span style="color: #a0522d;">=</span> <span style="color: #a020f0;">do</span>
  <span style="color: #228b22;">Ann</span>{annSortKey} <span style="color: #a0522d;">&lt;-</span> asks epAnn
  <span style="color: #a020f0;">let</span> ordered <span style="color: #a0522d;">=</span> <span style="color: #a020f0;">case</span> annSortKey <span style="color: #a020f0;">of</span>
                  <span style="color: #228b22;">NoAnnSortKey</span>    <span style="color: #a0522d;">-&gt;</span> sortBy orderByFst xs
                  <span style="color: #228b22;">Annsortkey</span> keys <span style="color: #a0522d;">-&gt;</span> orderByKey xs keys
  mapM_ snd ordered
</code></pre>
</div>

<div class="org-src-container">

<pre  class="src src-haskell"><code trim><span style="color: #a020f0;">data</span> <span style="color: #228b22;">AnnSortKey</span>
  <span style="color: #a0522d;">=</span> <span style="color: #228b22;">NoAnnSortKey</span>
  <span style="color: #a0522d;">|</span> <span style="color: #228b22;">AnnSortKey</span> [<span style="color: #228b22;">RealSrcSpan</span>]
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-orgb9ac0ee">
<h3 id="orgb9ac0ee">Usage for editing</h3>
<ul>
<li>Annotations are self-contained, so the SrcSpan is not important in
terms of printing AST fragments.  So freely able to delete, move,
duplicate fragments.
<ul>
<li>Note: <span class="underline">uniqueness</span> is important for ordering of binds,
declarations, etc</li>

</ul></li>
<li>Single pass, so no intermediate processing required.
<ul>
<li><i>To be confirmed. Currently having doubts</i></li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org90b04ad">
<h2 id="org90b04ad">Future directions</h2>
<ul>
<li>Some sort of printer combinators, derived from the annotations, or
<b>as</b> the annotations.</li>
<li>harmonisation between exact printing and ppr printing
<ul>
<li>Note: exact printing only feasible for <code class="src src-haskell"><span style="color: #228b22;">ParsedSource</span></code>.</li>

</ul></li>
<li>Update ParsedSource so that <code class="src src-haskell"><span style="color: #228b22;">AnnSortKey</span></code> is unnecessary</li>
<li>Sort out the <code class="src src-haskell"><span style="color: #228b22;">RdrName</span></code> &lt;-&gt; <code class="src src-haskell"><span style="color: #228b22;">Name</span></code> &lt;-&gt; <code class="src src-haskell"><span style="color: #228b22;">Id</span></code> mapping
<ul>
<li>This currently happens (for API tooling) via the
<code class="src src-haskell"><span style="color: #228b22;">LocatedN</span> <span style="color: #228b22;">RdrName</span></code> <code class="src src-haskell"><span style="color: #228b22;">SrcSpan</span></code>.</li>

</ul></li>
<li>Get rid of CPP in favour of a tooling-friendly option</li>

</ul>

</section>
</section>
<section>
<section id="slide-org0d5fc4a">
<h2 id="org0d5fc4a">Links</h2>
<ul>
<li>Presentation : <a href="https://alanz.github.io/hiw2020">https://alanz.github.io/hiw2020</a></li>
<li>GHC Wiki on in-tree-api-annotations
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/implementing-trees-that-grow/in-tree-api-annotations">https://gitlab.haskell.org/ghc/ghc/-/wikis/implementing-trees-that-grow/in-tree-api-annotations</a></li>

</ul></li>
<li>GHC issue: <a href="https://gitlab.haskell.org/ghc/ghc/-/issues/17638">#17638</a></li>
<li>GHC WIP Merge Request: <a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/2418">!2418</a>
<ul>
<li>"WIP: Proof of Concept implementation of in-tree API Annotations"</li>

</ul></li>
<li>GHC dev branch: <a href="https://gitlab.haskell.org/ghc/ghc/-/tree/wip/az/exactprint">wip/az/exactprint</a></li>
<li>Me
<ul>
<li>Twitter: <a href="https://twitter.com/@alan_zimm"><code class="src src-haskell"><span style="color: #a0522d;">@</span>alan_zimm</code></a></li>
<li>Github: <a href="https://github.com/alanz">https://github.com/alanz</a></li>

</ul></li>

</ul>
</section>
</section>
</div>
</div>
<script src="https://alanz.github.io/hiw2020/dist/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
width:1200, height:800, margin: 0.1, minScale:0.2, maxScale:2.5, slideNumber: 'c/t',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'https://alanz.github.io/hiw2020/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'https://alanz.github.io/hiw2020/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'https://alanz.github.io/hiw2020/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
